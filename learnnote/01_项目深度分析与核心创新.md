# MiroThinker 代码项目深度分析与核心创新

## 一、项目概览

MiroThinker 是 MiroMind 团队开发的开源深度研究 Agent，专注于研究和预测任务。在 GAIA 基准测试上达到 80.8% Avg@8 的成绩，是当前开源搜索 Agent 中的领先者。

核心组件：
- **miroflow-agent** — 主 Agent 框架（约 3500 行核心代码）
- **miroflow-tools** — 工具管理库（基于 MCP 协议）
- **gradio-demo** — Web 交互界面
- 基座模型：Qwen3 系列（30B / 235B）
- 训练数据：MiroVerse 数据集，147K 样本

---

## 二、项目结构

```
/apps/
├── miroflow-agent/                    # 主 Agent 实现
│   ├── src/
│   │   ├── core/                      # Agent 执行核心
│   │   │   ├── pipeline.py            # 任务执行管线
│   │   │   ├── orchestrator.py        # 主 Agent 编排器（1198 行，核心文件）
│   │   │   ├── tool_executor.py       # 工具调用执行
│   │   │   ├── answer_generator.py    # 最终答案生成
│   │   │   └── stream_handler.py      # SSE 流式输出
│   │   ├── llm/                       # LLM 提供商客户端
│   │   │   ├── base_client.py         # 抽象基类（上下文管理、token 保留策略）
│   │   │   ├── factory.py             # 客户端工厂
│   │   │   └── providers/
│   │   │       ├── openai_client.py   # OpenAI 兼容实现（主要使用）
│   │   │       └── anthropic_client.py
│   │   ├── config/
│   │   │   └── settings.py            # MCP Server 配置与环境变量
│   │   ├── utils/
│   │   │   ├── prompt_utils.py        # 系统 Prompt 与摘要 Prompt 模板
│   │   │   ├── parsing_utils.py       # 工具调用 XML 解析
│   │   │   └── wrapper_utils.py       # 响应包装器
│   │   ├── io/
│   │   │   ├── input_handler.py       # 输入处理
│   │   │   └── output_formatter.py    # 输出格式化（\boxed{} 提取）
│   │   └── logging/
│   │       └── task_logger.py         # 结构化日志
│   ├── conf/                          # Hydra 配置文件
│   │   ├── config.yaml                # 主配置入口
│   │   ├── agent/                     # Agent 配置
│   │   │   ├── mirothinker_v1.5_keep5_max200.yaml  # 推荐配置
│   │   │   ├── mirothinker_v1.5_keep5_max400.yaml  # BrowseComp 专用
│   │   │   └── ...
│   │   ├── llm/                       # LLM 配置
│   │   └── benchmark/                 # 基准测试配置
│   ├── benchmarks/                    # 评测脚本
│   └── main.py                        # 入口文件
├── miroflow-tools/                    # 工具管理库（MCP Server 实现）
├── gradio-demo/                       # Web UI
├── collect-trace/                     # 数据采集
└── visualize-trace/                   # 执行轨迹可视化
```

---

## 三、Prompt 体系分析

MiroThinker 的 prompt 设计分为四层，详见 `src/utils/prompt_utils.py`。

### 1. MCP System Prompt（工具使用指令）

```text
In this environment you have access to a set of tools you can use to answer the user's question.

You only have access to the tools provided below. You can only use one tool per message,
and will receive the result of that tool in the user's next response. You use tools step-by-step
to accomplish a given task, with each tool-use informed by the result of the previous tool-use.
Today is: {formatted_date}
```

关键设计点：
- 采用 **XML 标签**格式（`<use_mcp_tool>`）而非 JSON function calling，兼容开源模型（Qwen3 等）的文本生成能力
- 明确要求 "tool-use must be placed at the end of your response, top-level"，防止模型在文本中间嵌套工具调用
- 通用 objective 仅一句话："You accomplish a given task iteratively, breaking it down into clear steps and working through them methodically"——极其简洁

工具调用的 XML 格式：

```xml
<use_mcp_tool>
<server_name>server name here</server_name>
<tool_name>tool name here</tool_name>
<arguments>
{"param1": "value1", "param2": "value2"}
</arguments>
</use_mcp_tool>
```

### 2. Agent-Specific Prompt（角色定义）

- **Main Agent**：
  > "You are a task-solving agent that uses tools step-by-step to answer the user's question. Your goal is to provide complete, accurate and well-reasoned answers using additional tools."

- **Browsing Agent**：
  > "You are an agent that performs the task of searching and browsing the web for specific information... Do not infer, speculate, summarize broadly, or attempt to fill in missing parts yourself. Only return factual content."

特点：**极度克制**——没有冗长的角色描述或行为约束，完全依赖训练阶段的行为对齐。

### 3. Summary Prompt（最终回答生成）

这是最精细的 prompt，包含：
- `\boxed{}` 格式要求（与 GAIA 评测对齐）
- 详细的输出格式规范（数字、字符串、逗号分隔列表）
- 明确禁止工具调用："You must absolutely not perform any MCP tool call"
- "If a definitive answer could not be determined, make a well-informed educated guess"

核心内容：
```text
Summarize the above conversation, and output the FINAL ANSWER to the original question.
If a clear answer has already been provided earlier in the conversation, do not rethink or
recalculate it — simply extract that answer and reformat it to match the required format below.
...
Wrap your final answer in \boxed{}.
```

### 4. Failure Summary Prompt（失败经验模板）

```text
Failure type: [incomplete / blocked / misdirected / format_missed]
  - incomplete: ran out of turns before finishing
  - blocked: got stuck due to tool failure or missing information
  - misdirected: went down the wrong path
  - format_missed: found the answer but forgot to use \boxed{}
What happened: [describe the approach taken and why a final answer was not reached]
Useful findings: [list any facts, intermediate results, or conclusions discovered that should be reused]
```

这是 MiroThinker 独特的**结构化失败反思**机制，用于上下文压缩后的重试。

---

## 四、关键配置解读

以推荐配置 `mirothinker_v1.5_keep5_max200.yaml` 为例：

```yaml
main_agent:
  tools:
    - search_and_scrape_webpage    # Google 搜索（Serper API）
    - jina_scrape_llm_summary      # 网页抓取 + LLM 摘要
    - tool-python                  # E2B 沙箱 Python 执行
  tool_blacklist:
    - ["search_and_scrape_webpage", "sogou_search"]              # 禁用搜狗搜索
    - ["tool-python", "download_file_from_sandbox_to_local"]     # 禁用文件下载
  max_turns: 200

sub_agents:       # 无子 Agent（单 Agent 模式）

keep_tool_result: 5           # 仅保留最近 5 个工具返回结果
context_compress_limit: 5     # 启用上下文压缩，最多重试 5 次
```

关键参数含义：
- `keep_tool_result: 5` — 保留所有推理轨迹（assistant 消息），但只保留最近 5 个工具观察结果
- `context_compress_limit: 5` — 启用失败经验压缩机制，允许最多 5 次全流程重试
- `max_turns: 200` — 单次尝试最多 200 轮工具调用

---

## 五、与其他 Agent 框架的对比优势

### 1. Interactive Scaling（交互式扩展）—— 核心创新

| 维度 | 传统 Agent | MiroThinker |
|------|-----------|-------------|
| 模型规模 | 靠更大模型提升 | 同样支持 |
| 上下文长度 | 靠更长上下文 | 256K |
| **交互深度** | 通常 10-30 轮 | **200-600 轮工具调用** |

大多数 Agent 框架（如 LangChain ReAct、AutoGPT、OpenDevin）的工具调用轮次通常在 10-50 轮。MiroThinker 通过训练（MiroVerse 147K 样本）让模型学会在数百轮交互中保持一致性和目标导向，这是一个本质区别。

### 2. Context Retention Strategy（上下文保留策略）

实现位于 `base_client.py:124-220` 的 `_remove_tool_result_from_messages()`：
- 保留完整的**推理轨迹**（所有 assistant 消息）
- 只替换旧的工具返回内容为 `"Tool result is omitted to save tokens."`
- 始终保留第一条 user 消息（原始任务描述）

这比简单的 sliding window 或 summarization 更精妙：**模型知道自己做过什么（action trace），但不被旧的观察结果（observation）淹没。**

### 3. Context Compression + Failure Experience Retry

这是 MiroThinker 最独特的机制，实现在 `answer_generator.py:461-579`：

```
决策矩阵：
| 上下文管理 | 是否超时 | 行为                              |
|-----------|---------|-----------------------------------|
| OFF       | 任何     | 生成答案 → 回退到中间答案           |
| ON        | 否      | 生成答案 → 不回退，生成失败摘要      |
| ON        | 是      | 跳过答案生成 → 直接生成失败摘要      |
```

当开启 `context_compress_limit > 0` 时：
1. 如果本次尝试失败，生成结构化的 **Failure Experience Summary**
2. 将整个对话历史压缩为这个摘要
3. 在下一次尝试中，将失败经验作为前缀注入
4. 最多可以重试 `context_compress_limit` 次（默认 5 次）

这意味着 MiroThinker 实际上可以进行 **5 x 200 = 1000 轮** 的等效推理深度，同时每次都从失败中学习。

### 4. 多层容错和自修复

| 机制 | 代码位置 | 作用 |
|------|---------|------|
| MCP 格式错误检测 | `orchestrator.py:206` | 检测 XML 标签格式错误，自动回滚 |
| 拒绝关键词检测 | `orchestrator.py:229` | 检测 "I'm sorry" 等拒绝回复 |
| 重复查询去重 | `orchestrator.py:257-316` | 防止模型陷入搜索循环 |
| 工具参数自动修正 | `tool_executor.py:68-92` | 修复 LLM 常犯的参数命名错误 |
| 空搜索结果检测 | `tool_executor.py:154-183` | Google 搜索无结果时触发重试 |
| 重复内容检测 | `openai_client.py:196-222` | 检测 LLM 输出的严重重复 |
| 截断响应处理 | `openai_client.py:170-192` | `finish_reason=length` 时自动增大 max_tokens |
| 连续回滚上限 | 默认 5 次 | 防止无限重试循环 |

相比之下，LangChain 的 AgentExecutor 主要只有 `max_iterations` 和基本的异常处理。

### 5. 工具协议：MCP（Model Context Protocol）

MiroThinker 全面采用 MCP 标准：
- 工具通过 **Stdio MCP Server** 运行（独立进程）
- 支持热插拔工具配置
- 工具黑名单机制（`tool_blacklist` 配置项）
- 统一的工具管理器抽象（`miroflow-tools` 库）

相比 LangChain 的 Tool 类或 CrewAI 的 tool decorator，MCP 是一个更标准化、可扩展的工具接口协议。

### 6. 与具体框架的详细对比

| 特性 | MiroThinker | LangChain ReAct | AutoGPT | OpenDevin |
|------|------------|-----------------|---------|-----------|
| 最大工具调用轮次 | 200-600 | ~30 | ~50 | ~100 |
| 上下文管理 | 选择性保留 + 失败压缩 | 滑动窗口/摘要 | 文件存储 | 基本截断 |
| 失败重试机制 | 结构化失败经验 + 多次重试 | 无 | 简单重试 | 无 |
| 工具协议 | MCP 标准 | 自定义 Tool 类 | 插件系统 | 自定义 |
| 重复检测 | 查询级去重 | 无 | 无 | 无 |
| 模型训练 | 专用训练数据(147K) | 无（纯 prompt） | 无 | 部分 SFT |
| 多 Agent | 支持（主+子 Agent） | 支持 | 单 Agent | 支持 |
| 流式输出 | SSE 协议 | callback | 无 | WebSocket |

---

## 六、架构核心创新总结

### 创新 1：训练数据驱动 vs 纯 Prompt Engineering

MiroThinker 的 prompt **极其简洁**——核心系统 prompt 不到 30 行。所有复杂行为（多步推理、工具选择策略、错误恢复）都通过 MiroVerse 数据集训练到了模型权重中。这与 LangChain/AutoGPT 依赖冗长 prompt 来约束行为形成鲜明对比。

### 创新 2：Observation 选择性遗忘

`keep_tool_result=5` 的设计——保留所有 action 但只保留最近 5 个 observation——是一个很有洞察力的设计。它基于这样的认知：**模型需要知道自己做过什么（避免重复），但不需要记住每个工具返回的具体内容（节省空间给新的推理）。**

### 创新 3：Failure Experience as Context Compression

将失败经验结构化为 `[type, what_happened, useful_findings]` 并作为下一次尝试的输入，本质上是一种**经验压缩**机制。它比简单的 conversation summarization 更有目的性——不是压缩所有内容，而是提炼出对解决问题有用的信息。

### 创新 4：工程层面的鲁棒性

参数自动修正（`fix_tool_call_arguments`）、重复检测（`_check_duplicate_query`）、回滚限制（`MAX_CONSECUTIVE_ROLLBACKS`）——这些看似简单的工程措施，实际上解决了开源模型在长轨迹推理中最常见的失败模式。这种工程成熟度在其他开源 Agent 框架中较为罕见。

---

## 七、潜在改进空间

1. **并行工具调用**：当前每轮只执行一个工具调用（"You can only use one tool per message"），多工具并行可以显著提升效率
2. **动态工具选择**：所有工具在系统 prompt 中全量暴露，缺乏根据任务阶段动态调整可用工具的机制
3. **中间结果持久化**：目前只有 `intermediate_boxed_answers` 做了中间答案追踪，缺乏更通用的中间结果存储
4. **错误恢复策略**：回滚后简单重试，没有注入"请尝试不同策略"的 prompt 引导（Failure Experience 仅在跨轮次重试时使用）
